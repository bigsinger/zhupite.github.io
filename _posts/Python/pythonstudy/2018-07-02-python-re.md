---
layout:		post
category:	"python"
title:		"Python正则表达式"
tags:		[python]
---
- Content
{:toc}




# [正则表达式](http://blog.csdn.net/pleasecallmewhy/article/details/8929576)

# 基本规则

## 转义字符
```
\要用四个\，\\\\
"要用\"
```

## 常用函数
函数 | 说明
---|---
re.match() | 用正则表达式模式从字符串开头开始匹配    
re.search() | 匹配并提取第一个符合规律的内容，返回一个正则表达式对象（object）
re.sub() | 替换符合规律的内容，返回替换后的值
re.split() | 字符串分割  
re.findall(rule,target,[,flag])  | 在字符串中查找正则表达式模式的所有（非重复）出现；返回一个匹配对象的列表


网页内容分析规则：先抓大后抓小，两次findall。


符号 | 意义
---|---
.  | 匹配任意字符，换行符\n除外（re.S 让.匹配任何字符，包括换行符\n）当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。
*  | 0次或无限次
?  | 0次或1次
+ | 1个或多个
.* | 贪心算法（胖子）
.*? | 非贪心算法（婴儿，少吃多餐）
() | 捕获，括号内的数据作为结果返回
.{32} | 匹配任意字符32个
^ | 匹配字符串的开头
$ | 匹配字符串的末尾
{m,n} | m到n个
[…] | 用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’
[^…] | 不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。
re{ n}	re{ n,}	| 精确匹配n个前面表达式。
re{ n, m} | 匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式
a｜b| 匹配a或b
(re)| G匹配括号内的表达式，也表示一个组
(?imx)| 正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。
(?-imx)	| 正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。
(?: re)	| 类似 (…), 但是不表示一个组
(?imx: re)	| 在括号中使用i, m, 或 x 可选标志
(?-imx: re)	| 在括号中不使用i, m, 或 x 可选标志
(?#…)	| 注释.
(?= re)	| 前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。
(?! re)	| 前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功
(?> re)	| 匹配的独立模式，省去回溯。
\w	| 匹配字母数字
\W	| 匹配非字母数字
\s	| 匹配任意空白字符，等价于 [\t\n\r\f].
\S	| 匹配任意非空字符
\d	| 匹配任意数字，等价于 [0-9].
\D	| 匹配任意非数字
\A	| 匹配字符串开始
\Z	| 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。c
\z	| 匹配字符串结束
\G	| 匹配最后匹配完成的位置。
\b	| 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。
\B	| 匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。
\n, \t, 等.	| 匹配一个换行符。匹配一个制表符。等
\1…\9	| 匹配第n个分组的子表达式。
\10	| 匹配第n个分组的子表达式，如果它经匹配。否则指的是八进制字符码的表达式。


## []使用举例

举例 | 说明
---|---
[Pp]ython| 匹配 “Python” 或 “python”
rub[ye]	| 匹配 “ruby” 或 “rube”
[aeiou]	| 匹配中括号内的任意一个字母
[0-9]	| 匹配任何数字。类似于 [0123456789]
[a-z]	| 匹配任何小写字母
[A-Z]	| 匹配任何大写字母
[a-zA-Z0-9]	| 匹配任何字母及数字
[^aeiou]	| 除了aeiou字母以外的所有字符
[^0-9]	| 匹配除了数字外的字符


## 特殊字符\
举例 | 说明
---|---
.	| 匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用象 ‘[.\n]’ 的模式。
\d	| 匹配一个数字字符。等价于 [0-9]。
\D	| 匹配一个非数字字符。等价于 [^0-9]。
\s	| 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。
\S	| 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。
\w	| 匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]’。
\W	| 匹配任何非单词字符。等价于 ‘[^A-Za-z0-9_]’。
 \ [	| 匹配[
 \ ]	| 匹配]




## 常用
* re.match与re.search

```
#coding:utf-8

# re.match与re.search的区别
# re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。

import re

print(re.match('www', 'www.runoob.com').span())  # 在起始位置匹配
print(re.match('com', 'www.runoob.com'))         # 不在起始位置匹配

print(re.search('www', 'www.runoob.com').span())  # 在起始位置匹配
print(re.search('com', 'www.runoob.com').span())  # 不在起始位置匹配

line = "Cats are smarter than dogs"

matchObj = re.match( r'(.*) are (.*?) .*', line, re.M|re.I)

if matchObj:
   print "matchObj.group() : ", matchObj.group()
   print matchObj.groups()
   print "matchObj.group(1) : ", matchObj.group(1)
   print "matchObj.group(2) : ", matchObj.group(2)
else:
   print "No match!!"

searchObj = re.search( r'(.*) are (.*?) .*', line, re.M|re.I)

if searchObj:
   print "searchObj.group() : ", searchObj.group()
   print searchObj.groups()
   print "searchObj.group(1) : ", searchObj.group(1)
   print "searchObj.group(2) : ", searchObj.group(2)
else:
   print "Nothing found!!"


输出：
(0, 3)
None
(0, 3)
(11, 14)
matchObj.group() :  1Cats are smarter than dogs
('1Cats', 'smarter')
matchObj.group(1) :  1Cats
matchObj.group(2) :  smarter
searchObj.group() :  1Cats are smarter than dogs
('1Cats', 'smarter')
searchObj.group(1) :  1Cats
searchObj.group(2) :  smarter

```



```python
print(re.search('super', '1superstition').span())   # (1, 6)
```

* re.sub检索和替换

```
import re

phone = "2004-959-559 # This is Phone Number"

# Delete Python-style comments
num = re.sub(r'#.*$', "", phone)
print "Phone Num : ", num

# Remove anything other than digits
num = re.sub(r'\D', "", phone)    
print "Phone Num : ", num
```

* re.finditer查找迭代器

```
for n in re.finditer(r'\d+', 'one1two2three3four4'):
    print n.group()
```

* re.findall

```
re.findall(r'\d+', 'one1two2three3four4')
['1', '2', '3', '4']
```

* re.split

```
re.split(r'\d+', 'one1two2three3four4')
['one', 'two', 'three', 'four', '']
```

* flag正则表达式修饰符 – 可选标志
> 正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志：


修饰符 | 描述
---|---
re.I | 使匹配对大小写不敏感
re.L | 做本地化识别（locale-aware）匹配
re.M | 多行匹配，影响 ^ 和 $
re.S | 使 . 匹配包括换行在内的所有字符
re.U | 根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B.
re.X | 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。



### [正则表达式匹配模式](http://w3cschool.codecloud.net/python/python-reg-expression.html)

```
模式字符串使用特殊的语法来表示一个正则表达式：

字母和数字表示他们自身。一个正则表达式模式中的字母和数字匹配同样的字符串。

多数字母和数字前加一个反斜杠时会拥有不同的含义。

标点符号只有被转义时才匹配自身，否则它们表示特殊的含义。

反斜杠本身需要使用反斜杠转义。

由于正则表达式通常都包含反斜杠，所以你最好使用原始字符串来表示它们。模式元素(如 r’/t’，等价于’//t’)匹配相应的特殊字符。
```


- 邮箱地址email
```
r"(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$)"
```



关联：
[Python字符串查找和匹配](./python-string-find.html)、[Python字符串替换](./python-string-replace.html)